#############################################
# PostgreSQL Intelligent Performance â€“ ALL
# (drop into your flexible_server module)
#############################################

# ---------- variables.tf ----------
variable "enable_pg_perf_features" {
  description = "Turn on Performance Insights + Intelligent Performance (lower envs only)."
  type        = bool
  default     = false
}

variable "postgresql_extensions" {
  description = "Extensions to allow-list for Intelligent Performance/Index recommendations."
  type        = list(string)
  # Minimum set for Insights + Index recommendations:
  default     = ["pg_stat_statements", "pg_qualstats", "auto_explain", "hypopg"]
}

variable "perf_db_list" {
  description = "Databases where extensions should be created. Leave empty to skip DB object creation."
  type        = list(string)
  default     = []
}

# ---------- locals.tf (or top of main.tf) ----------
locals {
  # normalized, deduped, comma-joined list for the server config
  postgresql_extensions_csv = join(",", [for e in distinct(var.postgresql_extensions) : lower(trim(e))])
}

# ---------- SERVER-LEVEL allow-list & tuning (must be after server resource) ----------
# Allow-list extensions at the server level (portal 'Enable Intelligent Performance')
resource "azurerm_postgresql_flexible_server_configuration" "extensions_allowlist" {
  count     = var.enable_pg_perf_features && length(var.postgresql_extensions) > 0 ? 1 : 0
  name      = "azure.extensions"
  server_id = azurerm_postgresql_flexible_server.db.id
  value     = local.postgresql_extensions_csv
  depends_on = [azurerm_postgresql_flexible_server.db]
}

# Performance Insights (Query Performance Insight) relies on pg_stat_statements
resource "azurerm_postgresql_flexible_server_configuration" "pg_stat_statements_track" {
  count     = var.enable_pg_perf_features ? 1 : 0
  name      = "pg_stat_statements.track"
  server_id = azurerm_postgresql_flexible_server.db.id
  value     = "all"
}

resource "azurerm_postgresql_flexible_server_configuration" "pg_stat_statements_max" {
  count     = var.enable_pg_perf_features ? 1 : 0
  name      = "pg_stat_statements.max"
  server_id = azurerm_postgresql_flexible_server.db.id
  value     = "10000"
}

# Longer captured SQL text in pg_stat_activity (nicer in portal)
resource "azurerm_postgresql_flexible_server_configuration" "track_activity_query_size" {
  count     = var.enable_pg_perf_features ? 1 : 0
  name      = "track_activity_query_size"
  server_id = azurerm_postgresql_flexible_server.db.id
  value     = "16384"
}

# Optional: track planning phase in pg_stat_statements
resource "azurerm_postgresql_flexible_server_configuration" "pg_stat_statements_track_planning" {
  count     = var.enable_pg_perf_features ? 1 : 0
  name      = "pg_stat_statements.track_planning"
  server_id = azurerm_postgresql_flexible_server.db.id
  value     = "on"
}

# Helpful for index recommendations (qualstats thresholds)
resource "azurerm_postgresql_flexible_server_configuration" "pg_qualstats_compute_threshold" {
  count     = var.enable_pg_perf_features ? 1 : 0
  name      = "pg_qualstats.compute_threshold"
  server_id = azurerm_postgresql_flexible_server.db.id
  value     = "100"
}

# ---------- (OPTIONAL) DB-LEVEL extension creation ----------
# If you want Terraform to actually CREATE the extensions in each database,
# uncomment the provider below and the postgresql_extension resources.
# You must ensure network/firewall/identity allow this connection.

# provider "postgresql" {
#   host            = azurerm_postgresql_flexible_server.db.fqdn
#   port            = 5432
#   username        = "${random_string.db_server_username.result}@${azurerm_postgresql_flexible_server.db.name}"
#   password        = random_password.db_server_password.result
#   sslmode         = "require"
#   connect_timeout = 15
# }

# # Create each extension in each target DB
# resource "postgresql_extension" "perf_exts" {
#   for_each = var.enable_pg_perf_features && length(var.perf_db_list) > 0
#     ? { for db in var.perf_db_list : db => db }
#     : {}
#   name     = "" # placeholder; created via `postgresql_extension_per_db`
#   database = each.value
#   # This stub prevents provider complaining if list is empty; real creation below.
# }

# locals {
#   _ext_matrix = flatten([
#     for db in var.perf_db_list : [
#       for ext in var.postgresql_extensions : {
#         key = "${db}:${ext}"
#         db  = db
#         ext = ext
#       }
#     ]
#   ])
# }

# resource "postgresql_extension" "postgresql_extension_per_db" {
#   for_each = var.enable_pg_perf_features
#     ? { for m in local._ext_matrix : m.key => m }
#     : {}
#   name     = each.value.ext
#   database = each.value.db
#   depends_on = [azurerm_postgresql_flexible_server_configuration.extensions_allowlist]
# }

# ---------- HOW TO TURN ON ONLY IN LOWER ENVS ----------
# In dev/test/stg tfvars:
# enable_pg_perf_features = true
# perf_db_list            = ["app_db"]     # or any DBs you want to populate
# postgresql_extensions   = ["pg_stat_statements","pg_qualstats","auto_explain","hypopg"]
#
# In prod tfvars:
# enable_pg_perf_features = false
